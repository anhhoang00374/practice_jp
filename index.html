<!doctype html>
<html lang="vi">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>√în t·∫≠p ti·∫øng Nh·∫≠t ‚Äî Tr√¨nh ch·∫°y c√¢u</title>
    <style>
        :root{
            --bg: #f6f9fc;
            --card: #ffffff;
            --text: #1f2937;
            --muted: #6b7280;
            --brand: #3b82f6; /* xanh gi√°o d·ª•c d·ªãu */
            --brand-2: #10b981; /* xanh ng·ªçc d·ªãu */
            --danger: #ef4444;
            --shadow: 0 8px 24px rgba(27, 51, 89, .08);
            --radius: 16px;
        }
        *{box-sizing:border-box}
        body{
            margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
            background: radial-gradient(1200px 600px at 10% -10%, #e8f1ff 0%, transparent 40%),
            radial-gradient(1200px 600px at 120% 10%, #e9fff6 0%, transparent 40%),
            var(--bg);
            color:var(--text);
        }
        header{ padding: 20px clamp(16px, 4vw, 32px); display:flex; align-items:center; gap:16px; flex-wrap:wrap; }
        h1{font-size: clamp(18px, 2.4vw, 26px); margin:0}
        header p{margin:0; color:var(--muted)}

        main{padding: 8px clamp(16px, 4vw, 32px) 32px;}

        .panel{ background:var(--card); border-radius: var(--radius); padding: 16px; box-shadow: var(--shadow); }
        .grid{ display:grid; gap: 12px; }
        .grid.controls{ grid-template-columns: repeat(12, 1fr); align-items:end; }
        .control{ display:flex; flex-direction:column; gap:6px; }
        .control label{ font-size:12px; color:var(--muted) }
        .control select, .control input[type="range"], .control button{ width:100%; padding:10px 12px; border-radius:10px; border:1px solid #e5e7eb; background:#fff; color:var(--text); }
        .control input[type="range"]{ padding:0; }
        .row{ display:flex; gap:8px; flex-wrap:wrap; }

        .btn{ cursor:pointer; border:0; padding:10px 14px; border-radius:12px; font-weight:600; }
        .btn-primary{ background: linear-gradient(135deg, var(--brand), var(--brand-2)); color:#fff; }
        .btn-ghost{ background: #f3f4f6; color:#111827; }

        .status{ font-size: 12px; color: var(--muted); }

        .player{ margin-top:16px; display:grid; grid-template-columns: 1fr; gap:12px; }
        /* [FLIP] th√™m ph·ªëi c·∫£nh ƒë·ªÉ l·∫≠t 3D m∆∞·ª£t */
        .display{ min-height: 180px; display:grid; align-items:center; justify-items:center; text-align:center; padding: 24px; border-radius: var(--radius); background:#fff; box-shadow: var(--shadow); perspective: 1200px; }
        .sentence{ font-size: clamp(20px, 3.4vw, 36px); line-height:1.4; }
        .meta{ margin-top:8px; font-size:12px; color:var(--muted) }

        .controls-row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
        .chip{ padding:6px 10px; border-radius: 999px; font-size:12px; background:#eef2ff; color:#3730a3; }

        .progress{ height:8px; background:#e5e7eb; border-radius:999px; overflow:hidden; }
        .progress > div{ height:100%; background: linear-gradient(90deg, var(--brand), var(--brand-2)); width:0; }

        .hint{ font-size:11px; color:var(--muted); }

        /* [FLIP] card l·∫≠t hai m·∫∑t */
        .card{ position: relative; width:100%; min-height: 120px; transform-style: preserve-3d; transition: transform .6s ease; }
        .face{ position:absolute; inset:0; display:grid; place-items:center; padding:8px; backface-visibility: hidden; }
        .face-back{ transform: rotateY(180deg); }
        .d-none{
            display: none;
        }
        .full-width{
            width: 100%;
            text-align: center;
        }
        @media (max-width: 980px){ .grid.controls{ grid-template-columns: 1fr 1fr; } }
        @media (min-width: 981px){ .grid.controls{ grid-template-columns: repeat(12, 1fr); } .span-3{ grid-column: span 3; } .span-2{ grid-column: span 2; } .span-4{ grid-column: span 4; } }
    </style>
    <!-- N·∫°p d·ªØ li·ªáu tƒ©nh t·ª´ assets/main.js -->
    <script defer src="assets/main.js"></script>
</head>
<body>
<header>
<!--    <div class="logo">JP</div>-->
    <div class="full-width">
        <h1>√în t·∫≠p ti·∫øng Nh·∫≠t</h1>
        <p class="d-none">D·ªØ li·ªáu ƒë·ªçc tr·ª±c ti·∫øp t·ª´ <code>assets/main.js</code>. Ch·ªçn ng√†y ¬∑ Ch·ªçn ng√¥n ng·ªØ ¬∑ T·ª± ch·∫°y theo t·ªëc ƒë·ªô ¬∑ ƒê√°nh d·∫•u ƒë√£ thu·ªôc</p>
    </div>
</header>

<main class="grid" aria-live="polite">
    <!-- SUMMARY PANEL (kh√¥ng c√≤n khu v·ª±c n·∫°p file) -->
    <section class="panel grid controls d-none" id="summaryPanel">
        <div class="control span-4">
            <label>T·ªïng quan d·ªØ li·ªáu</label>
            <div class="chip" id="dataSummary">ƒêang ch·ªù d·ªØ li·ªáu t·ª´ <code>assets/main.js</code>‚Ä¶</div>
        </div>
        <div class="control span-8">
            <label>G·ª£i √Ω c·∫•u tr√∫c <code>assets/main.js</code></label>
            <div class="status">T·∫°o bi·∫øn global <code>window.JP_LESSONS = [ ... ]</code> (m·ªôt m·∫£ng nhi·ªÅu bu·ªïi, m·ªói bu·ªïi c√≥ <code>day</code>, <code>topic</code>, <code>sections.japanese[]</code> v√† <code>sections.vietnamese[]</code> ‚Äî m·ªói c√¢u c√≥ <code>id</code>, <code>text</code>).</div>
        </div>
    </section>

    <!-- FILTER / CONTROL PANEL -->
    <section class="panel grid controls" id="controlPanel" aria-disabled="true">
        <div class="control span-2">
            <label for="startDay">T·ª´ bu·ªïi</label>
            <select id="startDay"></select>
        </div>
        <div class="control span-2">
            <label for="endDay">ƒê·∫øn bu·ªïi</label>
            <select id="endDay"></select>
            <div class="status" id="rangeWarn" hidden>ƒê√£ t·ª± ƒëi·ªÅu ch·ªânh ƒë·ªÉ "ƒê·∫øn bu·ªïi" ‚â• "T·ª´ bu·ªïi".</div>
        </div>
        <div class="control span-3">
            <label for="language">Ng√¥n ng·ªØ √¥n t·∫≠p</label>
            <select id="language">
                <option value="japanese">Ti·∫øng Nh·∫≠t</option>
                <option value="vietnamese">Ti·∫øng Vi·ªát</option>
            </select>
        </div>
        <div class="control span-3">
            <label for="mode">Ch·∫ø ƒë·ªô √¥n</label>
            <select id="mode">
                <option value="all">T·∫•t c·∫£ c√¢u</option>
                <option value="unlearned">Ch·ªâ c√¢u ch∆∞a thu·ªôc</option>
            </select>
        </div>
        <div class="control span-2">
            <label for="speed">T·ªëc ƒë·ªô (gi√¢y/c√¢u): <span id="speedLabel">3</span>s</label>
            <input type="range" id="speed" min="1" max="10" step="0.5" value="3" />
        </div>
        <div class="control span-2">
            <label for="shuffle">Ng·∫´u nhi√™n</label>
            <select id="shuffle">
                <option value="off">T·∫Øt</option>
                <option value="on">B·∫≠t</option>
            </select>
        </div>
        <div class="control span-4">
            <label>&nbsp;</label>
            <div class="row">
                <button class="btn btn-primary" id="apply">C·∫≠p nh·∫≠t danh s√°ch</button>
                <button class="btn btn-ghost" id="resetLearned">Xo√° ƒë√°nh d·∫•u ƒë√£ thu·ªôc</button>
            </div>
        </div>
        <div class="control span-4">
            <label>Th·ªëng k√™</label>
            <div class="status" id="stats">‚Äî</div>
        </div>
    </section>

    <!-- PLAYER / DISPLAY -->
    <section class="player" id="player" aria-disabled="true">
        <div class="display" role="region" aria-live="polite" aria-atomic="true" id="display">
            <!-- [FLIP] th·∫ª card 2 m·∫∑t: m·∫∑t tr∆∞·ªõc ng√¥n ng·ªØ ch√≠nh, m·∫∑t sau b·∫£n d·ªãch -->
            <div class="card" id="card">
                <div class="face face-front">
                    <div class="sentence" id="faceFront">ƒêang ch·ªù d·ªØ li·ªáu t·ª´ assets/main.js‚Ä¶</div>
                </div>
                <div class="face face-back">
                    <div class="sentence" id="faceBack">(b·∫£n d·ªãch s·∫Ω hi·ªán ·ªü ƒë√¢y)</div>
                </div>
            </div>
            <div class="meta" id="meta"></div>
        </div>
        <div class="progress"><div id="bar"></div></div>
        <div class="controls-row">
            <button class="btn btn-primary" id="play" disabled>‚ñ∂Ô∏è B·∫Øt ƒë·∫ßu</button>
            <button class="btn btn-ghost" id="pause" disabled>‚è∏Ô∏è T·∫°m d·ª´ng</button>
            <button class="btn btn-ghost" id="prev" disabled>‚èÆÔ∏è L√πi</button>
            <button class="btn btn-ghost" id="next" disabled>‚è≠Ô∏è Ti·∫øp</button>
            <button class="btn btn-ghost" id="loop">üîÅ L·∫∑p: T·∫Øt</button>
            <button class="btn btn-ghost" id="mark" disabled>‚úÖ ƒê√°nh d·∫•u ƒë√£ thu·ªôc</button>
            <!-- [TTS] -->
            <button class="btn btn-ghost" id="ttsToggle" hidden>üîä Ph√°t √¢m: T·∫Øt</button>
            <button class="btn btn-ghost" id="ttsSpeak" hidden>üîà Ph√°t c√¢u n√†y</button>
            <span class="hint">Nh·∫•n v√†o th·∫ª ƒë·ªÉ l·∫≠t JP ‚áÑ VI ‚Ä¢ Ph√≠m t·∫Øt: Space (Play/Pause), ‚Üê/‚Üí (L√πi/Ti·∫øp), L (ƒê√°nh d·∫•u), F (L·∫≠t)</span>
        </div>
    </section>
</main>

<script>
    // ======= Tr·∫°ng th√°i ·ª©ng d·ª•ng (kh√¥ng ƒë·ªïi logic c≈©, ch·ªâ th√™m flip + TTS) =======
    const state = {
        lessons: [],               // d·ªØ li·ªáu g·ªëc t·ª´ JP_LESSONS
        pool: [],                  // danh s√°ch c√¢u sau khi l·ªçc
        idx: 0,
        timer: null,
        isPlaying: false,
        loop: false,
        prefsKey: 'jpReview:prefs:v2',
        learnedKey: (lang) => `jpReview:learned:${lang}:v1`,
        // [TTS]
        ttsEnabled: false,
        ttsReady: false,
        ttsVoice: null,
        // [FLIP]
        isFlipped: false,
    };

    // ======= DOM =======
    const $ = (sel) => document.querySelector(sel);
    const dataSummary = $('#dataSummary');

    const controlPanel= $('#controlPanel');
    const startDaySel = $('#startDay');
    const endDaySel   = $('#endDay');
    const languageSel = $('#language');
    const modeSel     = $('#mode');
    const speedRange  = $('#speed');
    const speedLabel  = $('#speedLabel');
    const shuffleSel  = $('#shuffle');
    const applyBtn    = $('#apply');
    const resetLearnedBtn = $('#resetLearned');
    const stats       = $('#stats');
    const rangeWarn   = $('#rangeWarn');

    const player      = $('#player');
    const barEl       = $('#bar');
    const playBtn     = $('#play');
    const pauseBtn    = $('#pause');
    const prevBtn     = $('#prev');
    const nextBtn     = $('#next');
    const loopBtn     = $('#loop');
    const markBtn     = $('#mark');
    const metaEl      = $('#meta');

    // [FLIP]
    const cardEl      = $('#card');
    const sentenceFrontEl  = $('#faceFront');
    const sentenceBackEl   = $('#faceBack');
    // Gi·ªØ t∆∞∆°ng th√≠ch: c√¢u hi·ªÉn th·ªã ch√≠nh (m·∫∑t tr∆∞·ªõc)
    const sentenceEl  = sentenceFrontEl;

    // [TTS]
    const ttsToggleBtn = $('#ttsToggle');
    const ttsSpeakBtn  = $('#ttsSpeak');

    // ======= Ti·ªán √≠ch =======
    function savePrefs() {
        const prefs = {
            language: languageSel.value,
            mode: modeSel.value,
            shuffle: shuffleSel.value,
            speed: Number(speedRange.value),
            startDay: Number(startDaySel.value || 1),
            endDay: Number(endDaySel.value || 1),
            loop: state.loop,
            ttsEnabled: state.ttsEnabled,
        };
        localStorage.setItem(state.prefsKey, JSON.stringify(prefs));
    }
    function loadPrefs() {
        try {
            const raw = localStorage.getItem(state.prefsKey);
            if (!raw) return;
            const prefs = JSON.parse(raw);
            if (prefs.language) languageSel.value = prefs.language;
            if (prefs.mode) modeSel.value = prefs.mode;
            if (prefs.shuffle) shuffleSel.value = prefs.shuffle;
            if (prefs.speed) speedRange.value = prefs.speed;
            speedLabel.textContent = speedRange.value;
            if (typeof prefs.loop === 'boolean') state.loop = prefs.loop;
            loopBtn.textContent = `üîÅ L·∫∑p: ${state.loop ? 'B·∫≠t' : 'T·∫Øt'}`;
            if (prefs.startDay) startDaySel.dataset.pref = prefs.startDay;
            if (prefs.endDay) endDaySel.dataset.pref = prefs.endDay;
            if (typeof prefs.ttsEnabled === 'boolean') state.ttsEnabled = prefs.ttsEnabled;
        } catch {}
    }

    function getLearnedSet(lang){
        try{ return new Set(JSON.parse(localStorage.getItem(state.learnedKey(lang))||'[]')); }
        catch{ return new Set(); }
    }
    function saveLearnedSet(lang, set){
        localStorage.setItem(state.learnedKey(lang), JSON.stringify(Array.from(set)));
    }

    function resetLearned(){
        ['japanese','vietnamese'].forEach(lang=> localStorage.removeItem(state.learnedKey(lang)) );
        updateStatsPreview();
        renderCurrent();
    }

    // [SAFE] Fisher‚ÄìYates, ch·ªëng d·ªØ li·ªáu kh√¥ng ph·∫£i m·∫£ng / ƒë·ªô d√†i l·∫°
    function shuffleInPlace(arr){
        if(!Array.isArray(arr)) return [];
        const n = arr.length >>> 0; // ƒë·∫£m b·∫£o s·ªë nguy√™n kh√¥ng √¢m
        if(n < 2) return arr;
        for(let i = n - 1; i > 0; i--){
            const j = Math.floor(Math.random() * (i + 1));
            const tmp = arr[i];
            arr[i] = arr[j];
            arr[j] = tmp;
        }
        return arr;
    }


    function enableControls(enabled){
        controlPanel.setAttribute('aria-disabled', !enabled);
        player.setAttribute('aria-disabled', !enabled);
        [applyBtn, resetLearnedBtn, startDaySel, endDaySel, languageSel, modeSel, speedRange, shuffleSel, playBtn].forEach(el=>{
            if (!el) return; el.disabled = !enabled;
        });
        updateTtsUI();

    }

    function summarizeData(){
        if(!state.lessons.length){ dataSummary.textContent='Ch∆∞a c√≥ d·ªØ li·ªáu'; return; }
        const days = state.lessons.map(l=>Number(l.day)).filter(n=>!Number.isNaN(n));
        if(days.length===0){ dataSummary.textContent='D·ªØ li·ªáu kh√¥ng c√≥ day h·ª£p l·ªá'; enableControls(false); return; }
        const min = Math.min(...days), max = Math.max(...days);
        let totalJP=0, totalVI=0;
        for(const l of state.lessons){
            totalJP += (l.sections?.japanese?.length || 0);
            totalVI += (l.sections?.vietnamese?.length || 0);
        }
        dataSummary.textContent = `C√≥ ${state.lessons.length} bu·ªïi (Day ${min} ‚Üí ${max}) ‚Ä¢ JP: ${totalJP} c√¢u ‚Ä¢ VI: ${totalVI} c√¢u`;
        populateDaySelects(min, max);
    }

    function populateDaySelects(min, max){
        startDaySel.innerHTML = '';
        endDaySel.innerHTML = '';
        for(let d=min; d<=max; d++){
            const o1=document.createElement('option'); o1.value=o1.textContent=d; startDaySel.appendChild(o1);
            const o2=document.createElement('option'); o2.value=o2.textContent=d; endDaySel.appendChild(o2);
        }
        const prefStart = Number(startDaySel.dataset.pref || min);
        const prefEnd = Number(endDaySel.dataset.pref || max);
        startDaySel.value = Math.max(min, Math.min(prefStart, max));
        endDaySel.value = Math.max(Number(startDaySel.value), Math.min(prefEnd, max));
        validateRange();
        updateStatsPreview();
    }

    function validateRange(){
        const s = Number(startDaySel.value);
        let e = Number(endDaySel.value);
        if(e < s){ e = s; endDaySel.value = String(e); rangeWarn.hidden = false; }
        else rangeWarn.hidden = true;
    }

    // ======= [FLIP] T√¨m c√¢u ƒë·ªëi ·ª©ng (∆∞u ti√™n theo id, sau ƒë√≥ theo ch·ªâ s·ªë) =======
    function getOppositeLang(lang){ return lang === 'japanese' ? 'vietnamese' : 'japanese'; }
    function findOppositeText(cur){
        const other = getOppositeLang(cur.lang);
        const byId = (arr, id)=> Array.isArray(arr) ? (arr.find(x=>x && x.id===id)?.text || null) : null;
        const lesson = state.lessons.find(l=> Number(l.day)===cur.day );
        if(lesson){
            // 1) th·ª≠ theo id trong c√πng bu·ªïi
            let t = byId(lesson.sections?.[other], cur.id);
            if(t) return t;
            // 2) fallback theo v·ªã tr√≠ t∆∞∆°ng ·ª©ng trong bu·ªïi
            const arr = Array.isArray(lesson.sections?.[other]) ? lesson.sections[other] : [];
            if(Number.isInteger(cur._idx) && arr[cur._idx] && typeof arr[cur._idx].text === 'string') return arr[cur._idx].text;
        }
        // 3) fallback to√†n c·ª•c theo id
        for(const l of state.lessons){
            const t = byId(l.sections?.[other], cur.id); if(t) return t;
        }
        return '(ch∆∞a c√≥ b·∫£n d·ªãch t∆∞∆°ng ·ª©ng)';
    }

    // ======= L·ªçc pool theo range + ch·∫ø ƒë·ªô =======
    function buildPool(){
        const s = Number(startDaySel.value), e = Number(endDaySel.value);
        const lang = languageSel.value;
        const mode = modeSel.value;
        const learned = getLearnedSet(lang);
        const pool = [];
        for(const lesson of state.lessons){
            const day = Number(lesson.day); if(Number.isNaN(day) || day < s || day > e) continue;
            const items = Array.isArray(lesson.sections?.[lang]) ? lesson.sections[lang] : [];
            for(let idx=0; idx<items.length; idx++){
                const it = items[idx];
                if(!it || typeof it.text !== 'string' || !it.id) continue;
                if(mode === 'unlearned' && learned.has(it.id)) continue;
                pool.push({ id: it.id, text: it.text, day, lang, _idx: idx });
            }
        }
        // if (shuffleSel.value === 'on') shuffleInPlace(pool);
        if (shuffleSel.value === 'on' && Array.isArray(pool) && pool.length > 1) shuffleInPlace(pool);
        state.pool = pool; state.idx = 0;
        updateStatsPreview();
        renderCurrent();
        updateNavButtons();
        savePrefs();
    }

    function updateStatsPreview(){
        if(!state.lessons.length){ stats.textContent='‚Äî'; return; }
        const s = Number(startDaySel.value||0), e = Number(endDaySel.value||0);
        const lang = languageSel.value;
        const learned = getLearnedSet(lang);
        let total=0, unlearned=0;
        for(const l of state.lessons){
            const day = Number(l.day); if(Number.isNaN(day) || day < s || day > e) continue;
            const arr = Array.isArray(l.sections?.[lang]) ? l.sections[lang] : [];
            for(const it of arr){ if(!it || !it.id) continue; total++; if(!learned.has(it.id)) unlearned++; }
        }
        stats.textContent = `Kho·∫£ng Day ${s} ‚Üí ${e} ‚Ä¢ ${lang==='japanese'?'JP':'VI'}: ${total} c√¢u ‚Ä¢ Ch∆∞a thu·ªôc: ${unlearned}`;
    }

    function renderCurrent(){
        const n = state.pool.length;
        if(n === 0){
            sentenceFrontEl.textContent = 'Kh√¥ng c√≥ c√¢u n√†o trong ph·∫°m vi / ch·∫ø ƒë·ªô ƒë√£ ch·ªçn.';
            sentenceBackEl.textContent = '';
            metaEl.textContent = '';
            barEl.style.width = '0%';
            markBtn.disabled = true; prevBtn.disabled = true; nextBtn.disabled = true;
            cardEl.classList.remove('flipped'); state.isFlipped = false;
            return;
        }
        const i = Math.max(0, Math.min(state.idx, n-1)); state.idx = i;
        const cur = state.pool[i];
        // [FLIP] c·∫≠p nh·∫≠t hai m·∫∑t
        sentenceFrontEl.textContent = cur.text;
        sentenceBackEl.textContent  = findOppositeText(cur);
        // meta
        metaEl.textContent = `#${i+1}/${n} ‚Ä¢ Day ${cur.day} ‚Ä¢ ${cur.lang==='japanese'?'JP':'VI'} ‚áÑ ${getOppositeLang(cur.lang)==='japanese'?'JP':'VI'} ‚Ä¢ ID: ${cur.id} ‚Ä¢ Nh·∫•n ƒë·ªÉ l·∫≠t`;
        barEl.style.width = `${((i+1)/n)*100}%`;
        // learned
        const learned = getLearnedSet(cur.lang);
        const isLearned = learned.has(cur.id);
        markBtn.textContent = isLearned ? '‚òëÔ∏è B·ªè ƒë√°nh d·∫•u' : '‚úÖ ƒê√°nh d·∫•u ƒë√£ thu·ªôc';
        markBtn.disabled = false; prevBtn.disabled = false; nextBtn.disabled = false;
        // lu√¥n hi·ªÉn th·ªã m·∫∑t tr∆∞·ªõc khi ƒë·ªïi c√¢u
        cardEl.classList.remove('flipped'); state.isFlipped = false;

        // [TTS] t·ª± ƒë·ªông ƒë·ªçc khi b·∫≠t v√† ƒëang ·ªü ti·∫øng Nh·∫≠t (m·∫∑t tr∆∞·ªõc)
        if(state.ttsEnabled && languageSel.value === 'japanese' && supportsTTS()){
            speakNow(cur.text);
        }
    }

    function updateNavButtons(){
        const disabled = state.pool.length === 0;
        [prevBtn, nextBtn, playBtn, pauseBtn, markBtn].forEach(b=> b.disabled = disabled);
        ttsSpeakBtn.disabled = disabled || languageSel.value !== 'japanese' || !supportsTTS();
    }

    // ======= Player =======
    function play(){
        if(state.isPlaying || state.pool.length===0) return;
        state.isPlaying = true;
        playBtn.disabled = true; pauseBtn.disabled = false;
        const tick = () => { if(!state.isPlaying) return; next(); };
        const interval = () => Number(speedRange.value) * 1000;
        function loop(){ if(!state.isPlaying) return; state.timer = setTimeout(()=>{ tick(); loop(); }, interval()); }
        loop();
    }
    function pause(){ state.isPlaying = false; playBtn.disabled = false; pauseBtn.disabled = true; if(state.timer) { clearTimeout(state.timer); state.timer = null; } cancelTTS(); }
    function next(){ if(state.pool.length===0) return; cancelTTS(); const atEnd = state.idx >= state.pool.length - 1; if(atEnd){ if(state.loop){ state.idx = 0; } else { pause(); return; } } else { state.idx++; } renderCurrent(); }
    function prev(){ if(state.pool.length===0) return; cancelTTS(); state.idx = Math.max(0, state.idx - 1); renderCurrent(); }
    function toggleLoop(){ state.loop = !state.loop; loopBtn.textContent = `üîÅ L·∫∑p: ${state.loop ? 'B·∫≠t' : 'T·∫Øt'}`; savePrefs(); }
    function toggleLearned(){ if(state.pool.length===0) return; const cur = state.pool[state.idx]; const set = getLearnedSet(cur.lang); const had = set.has(cur.id); if(had) set.delete(cur.id); else set.add(cur.id); saveLearnedSet(cur.lang, set); if(!had && modeSel.value === 'unlearned'){ state.pool.splice(state.idx, 1); if(state.idx >= state.pool.length) state.idx = Math.max(0, state.pool.length-1); } updateStatsPreview(); renderCurrent(); }

    // ======= [TTS] =======
    function supportsTTS(){ return 'speechSynthesis' in window && 'SpeechSynthesisUtterance' in window; }
    function ensureTTSVoice(){ if(!supportsTTS()) return; const synth = window.speechSynthesis; const pick = () => { const voices = synth.getVoices(); if(!voices || !voices.length) return false; state.ttsVoice = voices.find(v=>/ja(-|_)JP/i.test(v.lang)) || voices.find(v=>/^ja/i.test(v.lang)) || null; state.ttsReady = true; return true; }; if(!pick()){ synth.onvoiceschanged = () => { pick(); updateTtsUI(); }; } }
    function speakNow(text){ if(!supportsTTS() || !text) return; const u = new SpeechSynthesisUtterance(text); u.lang = (state.ttsVoice && state.ttsVoice.lang) || 'ja-JP'; if(state.ttsVoice) u.voice = state.ttsVoice; u.rate = 1.0; u.pitch = 1.0; window.speechSynthesis.cancel(); window.speechSynthesis.speak(u); }
    function cancelTTS(){ if(supportsTTS()) window.speechSynthesis.cancel(); }
    function updateTtsUI(){ const isJP = languageSel.value === 'japanese'; const can = supportsTTS(); ttsToggleBtn.hidden = !(isJP && can); ttsSpeakBtn.hidden  = !(isJP && can); ttsToggleBtn.textContent = `üîä Ph√°t √¢m: ${state.ttsEnabled ? 'B·∫≠t' : 'T·∫Øt'}`; ttsSpeakBtn.disabled = !isJP || !can || state.pool.length===0; }

    // ======= Chu·∫©n ho√° d·ªØ li·ªáu nh·∫π t·∫°i th·ªùi ƒëi·ªÉm n·∫°p (kh√¥ng ƒë·ªïi pipeline c≈©) =======
    function normalizeLesson(item){
        const dayNum = Number(item.day);
        const sections = item.sections || {};
        const jpRaw = Array.isArray(sections.japanese) ? sections.japanese : [];
        const viRaw = Array.isArray(sections.vietnamese) ? sections.vietnamese : [];
        const len = Math.max(jpRaw.length, viRaw.length);
        const jp = []; const vi = [];
        for(let i=0;i<len;i++){
            const j = jpRaw[i]; const v = viRaw[i];
            const pairId = (j && typeof j === 'object' && j.id) || (v && typeof v === 'object' && v.id) || `auto-${dayNum}-${i+1}`;
            if(typeof j === 'string') jp.push({ id: pairId, text: j });
            else if(j && typeof j.text === 'string') jp.push({ id: j.id || pairId, text: j.text });
            if(typeof v === 'string') vi.push({ id: pairId, text: v });
            else if(v && typeof v.text === 'string') vi.push({ id: v.id || pairId, text: v.text });
        }
        return { day: dayNum, topic: item.topic || '', sections: { japanese: jp, vietnamese: vi } };
    }

    // ======= N·∫†P D·ªÆ LI·ªÜU T·ª™ assets/main.js =======
    async function parseAndSetData(json){
        if(!Array.isArray(json)) throw new Error('JP_LESSONS ph·∫£i l√† m·∫£ng c√°c bu·ªïi h·ªçc');
        const lessons = [];

        for(const [i, item] of json.entries()){
            if(typeof item.day === 'undefined') throw new Error(`Ph·∫ßn t·ª≠ #${i} thi·∫øu tr∆∞·ªùng day`);
            if(!item.sections) throw new Error(`Ph·∫ßn t·ª≠ #${i} thi·∫øu sections`);
            const dayNum = Number(item.day); if(Number.isNaN(dayNum)) continue;
            lessons.push(normalizeLesson(item));
        }
        state.lessons = lessons;
        summarizeData();
        if(!lessons.length){ enableControls(false); return; }
        enableControls(true);
        buildPool();
    }

    // ======= S·ª± ki·ªán =======
    startDaySel.addEventListener('change', ()=>{ validateRange(); updateStatsPreview(); savePrefs(); });
    endDaySel.addEventListener('change', ()=>{ validateRange(); updateStatsPreview(); savePrefs(); });
    languageSel.addEventListener('change', ()=>{ updateStatsPreview(); updateTtsUI(); savePrefs(); if(languageSel.value!=='japanese') cancelTTS(); });
    modeSel.addEventListener('change', ()=>{ updateStatsPreview(); savePrefs(); });
    speedRange.addEventListener('input', ()=>{ speedLabel.textContent = speedRange.value; savePrefs(); });
    shuffleSel.addEventListener('change', savePrefs);

    applyBtn.addEventListener('click', buildPool);
    resetLearnedBtn.addEventListener('click', resetLearned);

    playBtn.addEventListener('click', play);
    pauseBtn.addEventListener('click', pause);
    prevBtn.addEventListener('click', prev);
    nextBtn.addEventListener('click', next);
    loopBtn.addEventListener('click', toggleLoop);
    markBtn.addEventListener('click', toggleLearned);

    // [TTS]
    ttsToggleBtn.addEventListener('click', ()=>{ state.ttsEnabled = !state.ttsEnabled; ttsToggleBtn.textContent = `üîä Ph√°t √¢m: ${state.ttsEnabled ? 'B·∫≠t' : 'T·∫Øt'}`; savePrefs(); if(!state.ttsEnabled) cancelTTS(); else if(languageSel.value==='japanese') speakNow(sentenceFrontEl.textContent); });
    ttsSpeakBtn.addEventListener('click', ()=>{ if(languageSel.value==='japanese') speakNow(sentenceFrontEl.textContent); });

    // [FLIP] nh·∫•p ƒë·ªÉ l·∫≠t v√† ph√≠m t·∫Øt F (ch·ªâ thay ƒë·ªïi hi·ªÉn th·ªã, kh√¥ng ƒë·ªïi logic d·ªØ li·ªáu)
    function toggleFlip(){ state.isFlipped = !state.isFlipped; cardEl.classList.toggle('flipped', state.isFlipped); }
    cardEl.addEventListener('click', toggleFlip);
    document.addEventListener('keydown', (e)=>{
        if(e.target && (e.target.tagName==='INPUT' || e.target.tagName==='SELECT' || e.target.isContentEditable)) return;
        if(e.code === 'Space'){ e.preventDefault(); state.isPlaying ? pause() : play(); }
        else if(e.code === 'ArrowRight'){ next(); }
        else if(e.code === 'ArrowLeft'){ prev(); }
        else if(e.key.toLowerCase() === 'l'){ toggleLearned(); }
        else if(e.key.toLowerCase() === 'f'){ toggleFlip(); }
    });

    // ======= Kh·ªüi t·∫°o =======
    (function init(){
        loadPrefs();
        ensureTTSVoice();
        window.addEventListener('DOMContentLoaded', ()=>{
            const data = window.JP_LESSONS;
            if(Array.isArray(data)){
                parseAndSetData(data).catch(err=>{ sentenceFrontEl.textContent = 'L·ªói d·ªØ li·ªáu: ' + err.message; });
            } else {
                sentenceFrontEl.textContent = 'Ch∆∞a t√¨m th·∫•y d·ªØ li·ªáu. H√£y t·∫°o assets/main.js v√† g√°n window.JP_LESSONS = [...].';
                enableControls(false);
            }
            updateTtsUI();
        });
    })();
</script>
</body>
</html>